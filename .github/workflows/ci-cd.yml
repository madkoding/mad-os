name: "CI/CD Pipeline"

on:
  push:
    branches: ["main", "develop"]
    tags:
      - 'v*'
    paths:
      - 'airootfs/**'
      - 'packages.x86_64'
      - 'profiledef.sh'
      - 'pacman.conf'
      - 'grub/**'
      - 'syslinux/**'
      - 'efiboot/**'
      - 'tests/**'
      - '.github/workflows/ci-cd.yml'
  pull_request:
    paths:
      - 'airootfs/**'
      - 'packages.x86_64'
      - 'profiledef.sh'
      - 'pacman.conf'
      - 'grub/**'
      - 'syslinux/**'
      - 'efiboot/**'
      - 'tests/**'
      - '.github/workflows/ci-cd.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests and validation (only for manual builds)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: ${{ !startsWith(github.ref, 'refs/tags/') }}

env:
  ARCHLINUX_IMAGE: archlinux:latest
  DNS_PRIMARY: "8.8.8.8"
  DNS_SECONDARY: "8.8.4.4"

jobs:
  # ================================================================
  # Stage 1: Code Quality & Static Analysis (r√°pido, paralelo)
  # ================================================================
  code-quality:
    name: "üîç Code Quality"
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.skip_tests }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install pytest shellcheck-py

      - name: Run ShellCheck on scripts
        run: |
          find airootfs/usr/local/bin -type f -executable | while read -r script; do
            if head -1 "$script" | grep -qE "(bash|sh)$"; then
              echo "Checking $script"
              shellcheck "$script" || true
            fi
          done
        continue-on-error: true

      - name: Validate Python syntax
        run: |
          find airootfs -name "*.py" -type f | while read -r script; do
            echo "Validating $script"
            python3 -m py_compile "$script"
          done

  # ================================================================
  # Stage 2: Unit Tests (agrupados por categor√≠a)
  # ================================================================
  test-unit:
    name: "üß™ Unit Tests: ${{ matrix.category }}"
    runs-on: ubuntu-latest
    needs: code-quality
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - category: "Core System"
            files: "tests/test_boot_scripts.py tests/test_post_installation.py tests/test_first_boot.py"
          - category: "AI & Desktop"
            files: "tests/test_opencode.py tests/test_ollama.py tests/test_hyprland_config.py"
          - category: "Hardware"
            files: "tests/test_gpu_detection.py tests/test_gpu_compute.py tests/test_wifi_backend.py"
          - category: "Apps & Media"
            files: "tests/test_equalizer_presets.py tests/test_photo_navigator.py tests/test_installer_config.py"
          - category: "Live USB"
            files: "tests/test_liveusb_scripts.py"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install test dependencies
        run: pip install pytest

      - name: Run unit tests
        run: |
          for file in ${{ matrix.files }}; do
            if [ -f "$file" ]; then
              echo "Running $file"
              python3 -m pytest "$file" -v
            else
              echo "Warning: $file not found"
            fi
          done

  # ================================================================
  # Stage 3: Integration Tests (todos juntos)
  # ================================================================
  test-integration:
    name: "üîó Integration Tests"
    runs-on: ubuntu-latest
    needs: code-quality
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        test:
          - name: "First-Boot Simulation"
            script: "tests/test-first-boot-simulation.sh"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run ${{ matrix.test.name }}
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash /build/${{ matrix.test.script }}

  # ================================================================
  # Stage 4: Installer Validation (despu√©s de tests)
  # ================================================================
  validate-installer:
    name: "‚úÖ Validate: ${{ matrix.component }}"
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration]
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        component:
          - name: "Python Modules"
            script: "tests/test-installer-python-validation.sh"
          - name: "Config Generation"
            script: "tests/test-installer-config-generation.sh"
          - name: "Disk Installation"
            script: "tests/test-installer-disk-install.sh"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run ${{ matrix.component.name }} validation
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash /build/${{ matrix.component.script }}

  # ================================================================
  # Stage 5a: Auto Version Tag (on branch pushes, not tag pushes)
  # ================================================================
  auto-tag:
    name: "üè∑Ô∏è Auto Version Tag"
    needs: validate-installer
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      new_tag: ${{ steps.create_tag.outputs.new_tag }}
      version: ${{ steps.create_tag.outputs.version }}
      is_release: ${{ steps.create_tag.outputs.is_release }}
      is_prerelease: ${{ steps.create_tag.outputs.is_prerelease }}
      release_type: ${{ steps.create_tag.outputs.release_type }}
      version_bump: ${{ steps.create_tag.outputs.version_bump }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create version tag
        id: create_tag
        run: |
          BRANCH="${GITHUB_REF#refs/heads/}"
          echo "Branch: $BRANCH"

          if [[ "$BRANCH" == "develop" ]]; then
            # --- Develop: analyze commits and create beta tag ---
            LAST_TAG=$(git tag -l --sort=-version:refname 'v*' | head -1)
            LAST_TAG="${LAST_TAG:-v0.0.0}"
            echo "Last tag: $LAST_TAG"

            BASE_VERSION=$(echo "$LAST_TAG" | sed 's/^v//; s/-.*$//')
            MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
            MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
            PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)

            # Analyze commits since last tag
            if git rev-parse "$LAST_TAG" >/dev/null 2>&1; then
              COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s" 2>/dev/null || echo "")
            else
              COMMITS=$(git log --pretty=format:"%s")
            fi

            HAS_BREAKING=false
            HAS_FEATURE=false
            HAS_FIX=false

            if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|^[a-zA-Z0-9]+!:"; then
              HAS_BREAKING=true
            fi
            if echo "$COMMITS" | grep -qiE "^feat(\(|:)"; then
              HAS_FEATURE=true
            fi
            if echo "$COMMITS" | grep -qiE "^fix(\(|:)|^hotfix(\(|:)"; then
              HAS_FIX=true
            fi

            BUMP="minor (default)"
            if [ "$HAS_BREAKING" = "true" ]; then
              MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0
              BUMP="major (breaking change)"
            elif [ "$HAS_FEATURE" = "true" ]; then
              MINOR=$((MINOR + 1)); PATCH=0
              BUMP="minor (feature)"
            elif [ "$HAS_FIX" = "true" ]; then
              PATCH=$((PATCH + 1))
              BUMP="patch (fix)"
            else
              MINOR=$((MINOR + 1)); PATCH=0
            fi

            NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}-beta"
            VERSION="${MAJOR}.${MINOR}.${PATCH}-beta"

            echo "version_bump=$BUMP" >> "$GITHUB_OUTPUT"
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "release_type=beta" >> "$GITHUB_OUTPUT"

          elif [[ "$BRANCH" == "main" ]]; then
            # --- Main: use last develop beta tag as reference ---
            LAST_BETA_TAG=$(git tag -l --sort=-version:refname 'v*-beta' | head -1)
            echo "Last beta tag: ${LAST_BETA_TAG:-none}"

            if [ -n "$LAST_BETA_TAG" ]; then
              # Strip -beta suffix to create release version
              VERSION=$(echo "$LAST_BETA_TAG" | sed 's/^v//; s/-beta$//')
              NEW_TAG="v${VERSION}"
              BUMP="from beta tag $LAST_BETA_TAG"
            else
              # Fallback: analyze commits for version bump
              LAST_STABLE_TAG=$(git tag -l --sort=-version:refname 'v*' | grep -v '-' | head -1)
              LAST_STABLE_TAG="${LAST_STABLE_TAG:-v0.0.0}"
              echo "Last stable tag: $LAST_STABLE_TAG"

              BASE_VERSION=$(echo "$LAST_STABLE_TAG" | sed 's/^v//')
              MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
              MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
              PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)

              if git rev-parse "$LAST_STABLE_TAG" >/dev/null 2>&1; then
                COMMITS=$(git log "${LAST_STABLE_TAG}..HEAD" --pretty=format:"%s" 2>/dev/null || echo "")
              else
                COMMITS=$(git log --pretty=format:"%s")
              fi

              HAS_BREAKING=false
              HAS_FEATURE=false
              HAS_FIX=false

              if echo "$COMMITS" | grep -qiE "BREAKING CHANGE|^[a-zA-Z0-9]+!:"; then
                HAS_BREAKING=true
              fi
              if echo "$COMMITS" | grep -qiE "^feat(\(|:)"; then
                HAS_FEATURE=true
              fi
              if echo "$COMMITS" | grep -qiE "^fix(\(|:)|^hotfix(\(|:)"; then
                HAS_FIX=true
              fi

              BUMP="minor (default)"
              if [ "$HAS_BREAKING" = "true" ]; then
                MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0
                BUMP="major (breaking change)"
              elif [ "$HAS_FEATURE" = "true" ]; then
                MINOR=$((MINOR + 1)); PATCH=0
                BUMP="minor (feature)"
              elif [ "$HAS_FIX" = "true" ]; then
                PATCH=$((PATCH + 1))
                BUMP="patch (fix)"
              else
                MINOR=$((MINOR + 1)); PATCH=0
              fi

              NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
              VERSION="${MAJOR}.${MINOR}.${PATCH}"
            fi

            echo "version_bump=$BUMP" >> "$GITHUB_OUTPUT"
            echo "is_release=true" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "release_type=stable" >> "$GITHUB_OUTPUT"
          fi

          # Check if tag already exists
          if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
            echo "::warning::Tag $NEW_TAG already exists, skipping tag creation"
            echo "new_tag=" >> "$GITHUB_OUTPUT"
            echo "version=" >> "$GITHUB_OUTPUT"
          else
            echo "‚úÖ Creating tag $NEW_TAG (bump: $BUMP)"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$NEW_TAG" -m "Auto-generated tag $NEW_TAG ($BUMP)"
            git push origin "$NEW_TAG"
            echo "new_tag=$NEW_TAG" >> "$GITHUB_OUTPUT"
            echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          fi

  # ================================================================
  # Stage 5b: Build ISO (siempre ejecuta en push a develop o main)
  # ================================================================
  build:
    name: "üèóÔ∏è Build ISO"
    needs: [validate-installer, auto-tag]
    if: |
      always() && !cancelled() &&
      (
        (needs.auto-tag.result == 'success' && needs.auto-tag.outputs.new_tag != '') ||
        (needs.auto-tag.result == 'skipped' && startsWith(github.ref, 'refs/tags/v')) ||
        github.event_name == 'workflow_dispatch'
      )
    runs-on: ubuntu-latest

    outputs:
      iso_file: ${{ steps.iso_info.outputs.iso_file }}
      iso_name: ${{ steps.iso_info.outputs.iso_name }}
      version: ${{ steps.iso_info.outputs.version }}
      build_date: ${{ steps.iso_info.outputs.build_date }}
      iso_size_mb: ${{ steps.iso_info.outputs.iso_size_mb }}
      short_sha: ${{ steps.iso_info.outputs.short_sha }}
      is_release: ${{ steps.build_type.outputs.is_release }}
      is_prerelease: ${{ steps.build_type.outputs.is_prerelease }}
      release_type: ${{ steps.build_type.outputs.release_type }}
      auto_tag: ${{ steps.build_type.outputs.auto_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para obtener todos los tags

      - name: Determine build type and version
        id: build_type
        run: |
          # Check if auto-tag job provided version info
          AUTO_TAG="${{ needs.auto-tag.outputs.new_tag }}"
          AUTO_VERSION="${{ needs.auto-tag.outputs.version }}"

          if [ -n "$AUTO_TAG" ]; then
            # Use version from auto-tag job
            echo "Using auto-tag: $AUTO_TAG (version: $AUTO_VERSION)"
            echo "is_release=${{ needs.auto-tag.outputs.is_release }}" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=${{ needs.auto-tag.outputs.is_prerelease }}" >> "$GITHUB_OUTPUT"
            echo "release_type=${{ needs.auto-tag.outputs.release_type }}" >> "$GITHUB_OUTPUT"
            echo "auto_tag=$AUTO_TAG" >> "$GITHUB_OUTPUT"
            echo "VERSION=$AUTO_VERSION" >> "$GITHUB_ENV"

          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            # Manual tag push: use the tag as-is
            TAG="${GITHUB_REF_NAME}"
            if [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-beta$ ]]; then
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=beta" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            elif [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-alpha$ ]]; then
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=alpha" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            elif [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "is_release=true" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
              echo "release_type=stable" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            else
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=dev" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            fi
            VERSION="${TAG#v}"
            echo "VERSION=$VERSION" >> "$GITHUB_ENV"

          else
            # Manual dispatch or other
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "release_type=dev" >> "$GITHUB_OUTPUT"
            echo "auto_tag=" >> "$GITHUB_OUTPUT"
          fi

      - name: Build ISO in Arch container
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash -c "
              echo 'nameserver ${{ env.DNS_PRIMARY }}' > /etc/resolv.conf
              echo 'nameserver ${{ env.DNS_SECONDARY }}' >> /etc/resolv.conf
              pacman-key --init
              pacman -Syu --noconfirm archiso
              cd /build
              mkarchiso -v -w /tmp/work -o /build/out .
              cd /build/out
              sha256sum *.iso > SHA256SUMS
              chmod -R 777 /build/out
            "

      - name: Extract build metadata
        id: iso_info
        run: |
          ISO_FILE=$(ls out/*.iso | head -1)
          ISO_NAME=$(basename "$ISO_FILE")
          
          # Usar la versi√≥n determinada en el paso anterior o calcularla
          if [ -n "$VERSION" ]; then
            # VERSION ya est√° seteada desde el paso build_type
            :
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="dev-$(date +%Y%m%d)"
          fi
          
          BUILD_DATE=$(date +%Y.%m.%d)
          ISO_SIZE=$(stat --format=%s "$ISO_FILE")
          ISO_SIZE_MB=$((ISO_SIZE / 1024 / 1024))
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "iso_file=$ISO_FILE" >> "$GITHUB_OUTPUT"
          echo "iso_name=$ISO_NAME" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          echo "iso_size_mb=$ISO_SIZE_MB" >> "$GITHUB_OUTPUT"
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v6
        with:
          name: mados-iso
          path: |
            out/*.iso
            out/SHA256SUMS
          retention-days: 7


  # ================================================================
  # Stage 6: Upload to Internet Archive (todas las builds)
  # ================================================================
  upload-archive:
    name: "üì¶ Upload to Archive"
    needs: build
    if: needs.build.result == 'success'
    runs-on: ubuntu-latest

    outputs:
      download_url: ${{ steps.upload_ia.outputs.download_url }}
      identifier: ${{ steps.upload_ia.outputs.identifier }}

    steps:
      - name: Download ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: mados-iso
          path: out

      - name: Install Internet Archive CLI
        run: pip install internetarchive

      - name: Upload to Internet Archive
        id: upload_ia
        env:
          IAS3_ACCESS_KEY: ${{ secrets.IA_ACCESS_KEY }}
          IAS3_SECRET_KEY: ${{ secrets.IA_SECRET_KEY }}
        run: |
          ISO_NAME="${{ needs.build.outputs.iso_name }}"
          VERSION="${{ needs.build.outputs.version }}"
          BUILD_DATE="${{ needs.build.outputs.build_date }}"
          RELEASE_TYPE="${{ needs.build.outputs.release_type }}"

          mkdir -p ~/.config/internetarchive
          cat > ~/.config/internetarchive/ia.ini <<EOF
          [s3]
          access = ${IAS3_ACCESS_KEY}
          secret = ${IAS3_SECRET_KEY}
          EOF
          chmod 600 ~/.config/internetarchive/ia.ini

          if [[ "$RELEASE_TYPE" == "stable" ]]; then
            IDENTIFIER="mados-${VERSION}"
            TITLE="madOS ${VERSION}"
          else
            SHORT_SHA="${{ needs.build.outputs.short_sha }}"
            IDENTIFIER="mados-${RELEASE_TYPE}-${VERSION}-${SHORT_SHA}"
            TYPE_LABEL=$(echo "${RELEASE_TYPE}" | sed 's/./\U&/')
            TITLE="madOS ${TYPE_LABEL} ${VERSION}"
          fi

          ISO_FILE=$(ls out/*.iso | head -1)

          ia upload "$IDENTIFIER" \
            "$ISO_FILE" \
            out/SHA256SUMS \
            --retries 3 \
            --metadata="title:${TITLE}" \
            --metadata="mediatype:software" \
            --metadata="collection:opensource" \
            --metadata="description:madOS - AI-Orchestrated Arch Linux Live ISO" \
            --metadata="subject:linux;arch;live-iso;open-source" \
            --metadata="creator:madOS Project" \
            --metadata="date:${BUILD_DATE}"

          DOWNLOAD_URL="https://archive.org/download/${IDENTIFIER}/${ISO_NAME}"
          echo "download_url=$DOWNLOAD_URL" >> "$GITHUB_OUTPUT"
          echo "identifier=$IDENTIFIER" >> "$GITHUB_OUTPUT"

  # ================================================================
  # Stage 7: GitHub Release (solo stable)
  # ================================================================
  release:
    name: "üöÄ GitHub Release"
    needs: [build, upload-archive]
    if: |
      needs.build.result == 'success' &&
      needs.upload-archive.result == 'success' &&
      needs.build.outputs.is_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: mados-iso
          path: out

      - name: Set release tag
        id: release_tag
        run: |
          if [ -n "${{ needs.build.outputs.auto_tag }}" ]; then
            echo "tag=${{ needs.build.outputs.auto_tag }}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_tag.outputs.tag }}
          name: |
            ${{ needs.build.outputs.is_release == 'true' && format('madOS {0}', needs.build.outputs.version) || format('madOS {0} ({1})', needs.build.outputs.version, needs.build.outputs.release_type) }}
          prerelease: ${{ needs.build.outputs.is_prerelease == 'true' }}
          append_body: true
          body: |

            ---

            **Versi√≥n:** `${{ needs.build.outputs.version }}`  
            **Commit:** `${{ github.sha }}`  
            **ISO:** `${{ needs.build.outputs.iso_name }}`  
            **Tama√±o:** ${{ needs.build.outputs.iso_size_mb }} MB

            ### üì• Descarga

            üåê **[Descargar ISO desde Internet Archive](${{ needs.upload-archive.outputs.download_url }})**

            ${{ needs.build.outputs.is_prerelease == 'true' && format('> ‚ö†Ô∏è Esta es una build de prueba ({0}). Para la versi√≥n estable, consulta la [√∫ltima release](https://github.com/{1}/releases/latest).', needs.build.outputs.release_type, github.repository) || '' }}

            ### ‚úÖ Verificaci√≥n

            Descarga tambi√©n el archivo `SHA256SUMS` y verifica:
            ```bash
            sha256sum -c SHA256SUMS
            ```
          files: |
            out/SHA256SUMS
          make_latest: ${{ needs.build.outputs.is_release == 'true' }}

  # ================================================================
  # Stage 8: Update Website Download Link (despu√©s de subir a IA)
  # ================================================================
  update-website:
    name: "üåê Update Website"
    needs: [build, upload-archive]
    if: |
      needs.build.result == 'success' &&
      needs.upload-archive.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Update Website Download Link
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          DOWNLOAD_URL="${{ needs.upload-archive.outputs.download_url }}"
          RELEASE_TYPE="${{ needs.build.outputs.release_type }}"

          # Determine which channel to update based on release type
          if [[ "$RELEASE_TYPE" == "stable" ]]; then
            CHANNEL="stable"
          else
            CHANNEL="beta"
          fi

          echo "Updating website with:"
          echo "  Version: $VERSION"
          echo "  URL: $DOWNLOAD_URL"
          echo "  Channel: $CHANNEL"

          # Pull latest main to avoid non-fast-forward errors
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin main

          # Update only the matching channel's download link
          sed -i "/data-channel=\"$CHANNEL\"/s|https://archive.org/download/mados-[^/]*/madOS-[^\"]*\.iso|$DOWNLOAD_URL|g" docs/index.html
          sed -i "/data-channel=\"$CHANNEL\"/s|data-version=\"[^\"]*\"|data-version=\"$VERSION\"|g" docs/index.html
          sed -i "s|<span id=\"${CHANNEL}-version-text\">Download v[^<]*</span>|<span id=\"${CHANNEL}-version-text\">Download v$VERSION</span>|g" docs/index.html

          if git diff --quiet docs/index.html; then
            echo "No changes needed in website"
          else
            git add docs/index.html
            git commit -m "üåê Update $CHANNEL download link to $VERSION [skip ci]"
            # Retry push with rebase in case of concurrent changes
            for i in 1 2 3; do
              if git push origin main; then
                echo "‚úÖ Website updated successfully"
                break
              else
                echo "‚ö†Ô∏è Push failed (attempt $i/3), rebasing and retrying..."
                git pull --rebase origin main
                sleep 2
              fi
            done
          fi
