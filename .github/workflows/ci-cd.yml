name: "CI/CD Pipeline"

on:
  push:
    branches: ["main", "develop"]
    tags:
      - 'v*'
    paths:
      - 'airootfs/**'
      - 'packages.x86_64'
      - 'profiledef.sh'
      - 'pacman.conf'
      - 'grub/**'
      - 'syslinux/**'
      - 'efiboot/**'
      - 'tests/**'
      - '.github/workflows/ci-cd.yml'
  pull_request:
    paths:
      - 'airootfs/**'
      - 'packages.x86_64'
      - 'profiledef.sh'
      - 'pacman.conf'
      - 'grub/**'
      - 'syslinux/**'
      - 'efiboot/**'
      - 'tests/**'
      - '.github/workflows/ci-cd.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests and validation (only for manual builds)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ci-cd-${{ github.ref }}
  cancel-in-progress: ${{ !startsWith(github.ref, 'refs/tags/') }}

env:
  ARCHLINUX_IMAGE: archlinux:latest
  DNS_PRIMARY: "8.8.8.8"
  DNS_SECONDARY: "8.8.4.4"

jobs:
  # ================================================================
  # Stage 1: Code Quality & Static Analysis (r√°pido, paralelo)
  # ================================================================
  code-quality:
    name: "üîç Code Quality"
    runs-on: ubuntu-latest
    if: ${{ !github.event.inputs.skip_tests }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          pip install pytest shellcheck-py

      - name: Run ShellCheck on scripts
        run: |
          find airootfs/usr/local/bin -type f -executable | while read -r script; do
            if head -1 "$script" | grep -qE "(bash|sh)$"; then
              echo "Checking $script"
              shellcheck "$script" || true
            fi
          done
        continue-on-error: true

      - name: Validate Python syntax
        run: |
          find airootfs -name "*.py" -type f | while read -r script; do
            echo "Validating $script"
            python3 -m py_compile "$script"
          done

  # ================================================================
  # Stage 2: Unit Tests (agrupados por categor√≠a)
  # ================================================================
  test-unit:
    name: "üß™ Unit Tests: ${{ matrix.category }}"
    runs-on: ubuntu-latest
    needs: code-quality
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - category: "Core System"
            files: "tests/test_boot_scripts.py tests/test_post_installation.py tests/test_first_boot.py"
          - category: "AI & Desktop"
            files: "tests/test_opencode.py tests/test_ollama.py tests/test_hyprland_config.py"
          - category: "Hardware"
            files: "tests/test_gpu_detection.py tests/test_gpu_compute.py tests/test_wifi_backend.py"
          - category: "Apps & Media"
            files: "tests/test_equalizer_presets.py tests/test_photo_navigator.py tests/test_installer_config.py"
          - category: "Live USB"
            files: "tests/test_persistence_scripts.py tests/test_liveusb_scripts.py"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install test dependencies
        run: pip install pytest

      - name: Run unit tests
        run: |
          for file in ${{ matrix.files }}; do
            if [ -f "$file" ]; then
              echo "Running $file"
              python3 -m pytest "$file" -v
            else
              echo "Warning: $file not found"
            fi
          done

  # ================================================================
  # Stage 3: Integration Tests (todos juntos)
  # ================================================================
  test-integration:
    name: "üîó Integration Tests"
    runs-on: ubuntu-latest
    needs: code-quality
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        test:
          - name: "USB Persistence"
            script: "tests/test-liveusb-persistence.sh"
          - name: "Isohybrid Detection"
            script: "tests/test-liveusb-isohybrid.sh"
          - name: "First-Boot Simulation"
            script: "tests/test-first-boot-simulation.sh"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run ${{ matrix.test.name }}
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash /build/${{ matrix.test.script }}

  # ================================================================
  # Stage 4: Installer Validation (despu√©s de tests)
  # ================================================================
  validate-installer:
    name: "‚úÖ Validate: ${{ matrix.component }}"
    runs-on: ubuntu-latest
    needs: [test-unit, test-integration]
    if: ${{ !github.event.inputs.skip_tests }}
    strategy:
      fail-fast: false
      matrix:
        component:
          - name: "Python Modules"
            script: "tests/test-installer-python-validation.sh"
          - name: "Config Generation"
            script: "tests/test-installer-config-generation.sh"
          - name: "Disk Installation"
            script: "tests/test-installer-disk-install.sh"

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run ${{ matrix.component.name }} validation
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash /build/${{ matrix.component.script }}

  # ================================================================
  # Stage 5: Build ISO
  # ================================================================
  build:
    name: "üèóÔ∏è Build ISO"
    needs: validate-installer
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest

    outputs:
      iso_file: ${{ steps.iso_info.outputs.iso_file }}
      iso_name: ${{ steps.iso_info.outputs.iso_name }}
      version: ${{ steps.iso_info.outputs.version }}
      build_date: ${{ steps.iso_info.outputs.build_date }}
      iso_size_mb: ${{ steps.iso_info.outputs.iso_size_mb }}
      short_sha: ${{ steps.iso_info.outputs.short_sha }}
      is_release: ${{ steps.build_type.outputs.is_release }}
      is_prerelease: ${{ steps.build_type.outputs.is_prerelease }}
      release_type: ${{ steps.build_type.outputs.release_type }}
      auto_tag: ${{ steps.build_type.outputs.auto_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para obtener todos los tags

      - name: Analyze commits for version bump
        id: version_analysis
        run: |
          # Obtener √∫ltima versi√≥n de tag
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          BASE_VERSION=$(echo "$LAST_TAG" | sed 's/^v//; s/-.*$//')
          
          # Parse version components
          MAJOR=$(echo "$BASE_VERSION" | cut -d. -f1)
          MINOR=$(echo "$BASE_VERSION" | cut -d. -f2)
          PATCH=$(echo "$BASE_VERSION" | cut -d. -f3)
          
          # Analizar commits desde el √∫ltimo tag
          COMMITS=$(git log "${LAST_TAG}..HEAD" --pretty=format:"%s" 2>/dev/null || echo "")
          
          # Detectar tipo de cambio
          HAS_FEATURE=false
          HAS_FIX=false
          
          if echo "$COMMITS" | grep -qiE "^feat\(|feature\(|^feat:"; then
            HAS_FEATURE=true
          fi
          
          if echo "$COMMITS" | grep -qiE "^fix\(|hotfix\(|^fix:|^hotfix:"; then
            HAS_FIX=true
          fi
          
          echo "has_feature=$HAS_FEATURE" >> "$GITHUB_OUTPUT"
          echo "has_fix=$HAS_FIX" >> "$GITHUB_OUTPUT"
          echo "last_tag=$LAST_TAG" >> "$GITHUB_OUTPUT"
          echo "base_version=$BASE_VERSION" >> "$GITHUB_OUTPUT"
          echo "major=$MAJOR" >> "$GITHUB_OUTPUT"
          echo "minor=$MINOR" >> "$GITHUB_OUTPUT"
          echo "patch=$PATCH" >> "$GITHUB_OUTPUT"

      - name: Determine build type and version
        id: build_type
        run: |
          # Obtener valores del paso anterior
          HAS_FEATURE="${{ steps.version_analysis.outputs.has_feature }}"
          HAS_FIX="${{ steps.version_analysis.outputs.has_fix }}"
          MAJOR="${{ steps.version_analysis.outputs.major }}"
          MINOR="${{ steps.version_analysis.outputs.minor }}"
          PATCH="${{ steps.version_analysis.outputs.patch }}"
          
          if [[ "$GITHUB_REF" == refs/heads/develop ]]; then
            # Develop: analizar commits y determinar bump
            if [ "$HAS_FEATURE" = "true" ]; then
              # Feature: incrementar minor, reset patch
              NEW_MINOR=$((MINOR + 1))
              VERSION="${MAJOR}.${NEW_MINOR}.0-beta"
              echo "version_bump=minor (feature)" >> "$GITHUB_OUTPUT"
            elif [ "$HAS_FIX" = "true" ]; then
              # Fix/Hotfix: incrementar patch
              NEW_PATCH=$((PATCH + 1))
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}-beta"
              echo "version_bump=patch (fix/hotfix)" >> "$GITHUB_OUTPUT"
            else
              # Sin cambio sem√°ntico detectado: minor por defecto
              NEW_MINOR=$((MINOR + 1))
              VERSION="${MAJOR}.${NEW_MINOR}.0-beta"
              echo "version_bump=minor (default)" >> "$GITHUB_OUTPUT"
            fi
            
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "release_type=beta" >> "$GITHUB_OUTPUT"
            echo "auto_tag=v${VERSION}" >> "$GITHUB_OUTPUT"
            
          elif [[ "$GITHUB_REF" == refs/heads/main ]]; then
            # Main: merge desde develop ‚Üí auto tag de producci√≥n
            if [ "$HAS_FEATURE" = "true" ]; then
              NEW_MINOR=$((MINOR + 1))
              VERSION="${MAJOR}.${NEW_MINOR}.0"
              echo "version_bump=minor (feature)" >> "$GITHUB_OUTPUT"
            elif [ "$HAS_FIX" = "true" ]; then
              NEW_PATCH=$((PATCH + 1))
              VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
              echo "version_bump=patch (fix/hotfix)" >> "$GITHUB_OUTPUT"
            else
              # Default: minor bump
              NEW_MINOR=$((MINOR + 1))
              VERSION="${MAJOR}.${NEW_MINOR}.0"
              echo "version_bump=minor (default)" >> "$GITHUB_OUTPUT"
            fi
            
            echo "is_release=true" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
            echo "release_type=stable" >> "$GITHUB_OUTPUT"
            echo "auto_tag=v${VERSION}" >> "$GITHUB_OUTPUT"
            
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            # Tag manual: usar el tag tal cual
            TAG="${GITHUB_REF_NAME}"
            if [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-beta$ ]]; then
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=beta" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            elif [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+-alpha$ ]]; then
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=alpha" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            elif [[ "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "is_release=true" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=false" >> "$GITHUB_OUTPUT"
              echo "release_type=stable" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            else
              echo "is_release=false" >> "$GITHUB_OUTPUT"
              echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
              echo "release_type=dev" >> "$GITHUB_OUTPUT"
              echo "auto_tag=" >> "$GITHUB_OUTPUT"
            fi
          else
            # Main sin tag o manual dispatch
            echo "is_release=false" >> "$GITHUB_OUTPUT"
            echo "is_prerelease=true" >> "$GITHUB_OUTPUT"
            echo "release_type=dev" >> "$GITHUB_OUTPUT"
            echo "auto_tag=" >> "$GITHUB_OUTPUT"
          fi
          
          echo "version=$VERSION" >> "$GITHUB_ENV"

      - name: Build ISO in Arch container
        run: |
          docker run --privileged --rm \
            --dns ${{ env.DNS_PRIMARY }} --dns ${{ env.DNS_SECONDARY }} \
            -v ${{ github.workspace }}:/build \
            ${{ env.ARCHLINUX_IMAGE }} bash -c "
              echo 'nameserver ${{ env.DNS_PRIMARY }}' > /etc/resolv.conf
              echo 'nameserver ${{ env.DNS_SECONDARY }}' >> /etc/resolv.conf
              pacman-key --init
              pacman -Syu --noconfirm archiso
              cd /build
              mkarchiso -v -w /tmp/work -o /build/out .
              cd /build/out
              sha256sum *.iso > SHA256SUMS
              chmod -R 777 /build/out
            "

      - name: Extract build metadata
        id: iso_info
        run: |
          ISO_FILE=$(ls out/*.iso | head -1)
          ISO_NAME=$(basename "$ISO_FILE")
          
          # Usar la versi√≥n determinada en el paso anterior o calcularla
          if [ -n "$VERSION" ]; then
            # VERSION ya est√° seteada desde el paso build_type
            :
          elif [[ "$GITHUB_REF" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF_NAME#v}"
          else
            VERSION="dev-$(date +%Y%m%d)"
          fi
          
          BUILD_DATE=$(date +%Y.%m.%d)
          ISO_SIZE=$(stat --format=%s "$ISO_FILE")
          ISO_SIZE_MB=$((ISO_SIZE / 1024 / 1024))
          SHORT_SHA=$(echo "$GITHUB_SHA" | cut -c1-7)
          echo "iso_file=$ISO_FILE" >> "$GITHUB_OUTPUT"
          echo "iso_name=$ISO_NAME" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"
          echo "iso_size_mb=$ISO_SIZE_MB" >> "$GITHUB_OUTPUT"
          echo "short_sha=$SHORT_SHA" >> "$GITHUB_OUTPUT"

      - name: Upload ISO artifact
        uses: actions/upload-artifact@v6
        with:
          name: mados-iso
          path: |
            out/*.iso
            out/SHA256SUMS
          retention-days: 7


  # ================================================================
  # Stage 6: Release (despu√©s del build exitoso)
  # ================================================================
  release:
    name: "üöÄ Release & Deploy"
    needs: build
    if: (startsWith(github.ref, 'refs/tags/v') && needs.build.outputs.is_release == 'true') || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download ISO artifact
        uses: actions/download-artifact@v4
        with:
          name: mados-iso
          path: out

      # ---------- Sub-stage 6.1: Upload to Internet Archive ----------
      - name: Install Internet Archive CLI
        run: pip install internetarchive

      - name: Upload to Internet Archive
        id: upload_ia
        env:
          IAS3_ACCESS_KEY: ${{ secrets.IA_ACCESS_KEY }}
          IAS3_SECRET_KEY: ${{ secrets.IA_SECRET_KEY }}
        run: |
          ISO_NAME="${{ needs.build.outputs.iso_name }}"
          VERSION="${{ needs.build.outputs.version }}"
          BUILD_DATE="${{ needs.build.outputs.build_date }}"
          RELEASE_TYPE="${{ needs.build.outputs.release_type }}"

          mkdir -p ~/.config/internetarchive
          cat > ~/.config/internetarchive/ia.ini <<EOF
          [s3]
          access = ${IAS3_ACCESS_KEY}
          secret = ${IAS3_SECRET_KEY}
          EOF
          chmod 600 ~/.config/internetarchive/ia.ini

          if [[ "$RELEASE_TYPE" == "stable" ]]; then
            IDENTIFIER="mados-${VERSION}"
            TITLE="madOS ${VERSION}"
          else
            SHORT_SHA="${{ needs.build.outputs.short_sha }}"
            IDENTIFIER="mados-${RELEASE_TYPE}-${VERSION}-${SHORT_SHA}"
            TYPE_LABEL=$(echo "${RELEASE_TYPE}" | sed 's/./\U&/')
            TITLE="madOS ${TYPE_LABEL} ${VERSION}"
          fi

          ISO_FILE=$(ls out/*.iso | head -1)

          ia upload "$IDENTIFIER" \
            "$ISO_FILE" \
            out/SHA256SUMS \
            --retries 3 \
            --metadata="title:${TITLE}" \
            --metadata="mediatype:software" \
            --metadata="collection:opensource" \
            --metadata="description:madOS - AI-Orchestrated Arch Linux Live ISO" \
            --metadata="subject:linux;arch;live-iso;open-source" \
            --metadata="creator:madOS Project" \
            --metadata="date:${BUILD_DATE}"

          DOWNLOAD_URL="https://archive.org/download/${IDENTIFIER}/${ISO_NAME}"
          echo "download_url=$DOWNLOAD_URL" >> "$GITHUB_OUTPUT"
          echo "identifier=$IDENTIFIER" >> "$GITHUB_OUTPUT"

      # ---------- Sub-stage 6.2: Create GitHub Release ----------
      - name: Set release tag
        id: release_tag
        run: |
          echo "tag=${{ github.ref_name }}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_tag.outputs.tag }}
          name: |
            ${{ needs.build.outputs.is_release == 'true' && format('madOS {0}', needs.build.outputs.version) || format('madOS {0} ({1})', needs.build.outputs.version, needs.build.outputs.release_type) }}
          prerelease: ${{ needs.build.outputs.is_prerelease == 'true' }}
          append_body: true
          body: |

            ---

            **Versi√≥n:** `${{ needs.build.outputs.version }}`  
            **Commit:** `${{ github.sha }}`  
            **ISO:** `${{ needs.build.outputs.iso_name }}`  
            **Tama√±o:** ${{ needs.build.outputs.iso_size_mb }} MB

            ### üì• Descarga

            üåê **[Descargar ISO desde Internet Archive](${{ steps.upload_ia.outputs.download_url }})**

            ${{ needs.build.outputs.is_prerelease == 'true' && format('> ‚ö†Ô∏è Esta es una build de prueba ({0}). Para la versi√≥n estable, consulta la [√∫ltima release](https://github.com/{1}/releases/latest).', needs.build.outputs.release_type, github.repository) || '' }}

            ### ‚úÖ Verificaci√≥n

            Descarga tambi√©n el archivo `SHA256SUMS` y verifica:
            ```bash
            sha256sum -c SHA256SUMS
            ```
          files: |
            out/SHA256SUMS
          make_latest: ${{ needs.build.outputs.is_release == 'true' }}

      # ---------- Sub-stage 6.3: Update Website (solo stable) ----------
      - name: Update Website Download Link
        if: needs.build.outputs.is_release == 'true'
        run: |
          DOWNLOAD_URL="${{ steps.upload_ia.outputs.download_url }}"
          ISO_NAME="${{ needs.build.outputs.iso_name }}"
          VERSION="${{ needs.build.outputs.version }}"

          git fetch origin main
          git checkout main

          sed -i "s|https://archive.org/download/mados-[^/]*/madOS-[^\"]*\.iso|$DOWNLOAD_URL|g" docs/index.html
          sed -i "s|data-version=\"[^\"]*\"|data-version=\"$VERSION\"|g" docs/index.html

          if git diff --quiet docs/index.html; then
            echo "No changes needed in website"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add docs/index.html
            git commit -m "Update download link and version to $VERSION [skip ci]"
            git push origin main
          fi
