#!/usr/bin/env bash
# mados-wallpaper-glitch - Random per-workspace wallpapers with glitch transitions for Hyprland
# On startup, assigns a random wallpaper from /usr/share/backgrounds/
# to each workspace and switches wallpaper with cyberpunk glitch effects
# on workspace focus events via Hyprland IPC socket.
#
# Wallpaper catalog and per-workspace assignments are stored in a SQLite
# database at ~/.local/share/mados/wallpapers.db so they persist across
# reboots and can be read/edited by a future wallpaper-settings GUI.

WALLPAPER_DIR="/usr/share/backgrounds"
MAX_WORKSPACES=5
LOG_TAG="mados-wallpaper-glitch"
DB_DIR="${HOME}/.local/share/mados"
DB_PATH="${DB_DIR}/wallpapers.db"

# Transition effects that simulate digital interference / glitch
TRANSITIONS=("pixelate" "wave" "wipe" "grow")

log() {
    logger -p user.info -t "$LOG_TAG" "$*" 2>/dev/null || true
    echo "$LOG_TAG: $*" >&2
}

cleanup() {
    log "daemon exiting, database preserved at $DB_PATH"
}
trap cleanup EXIT

# Kill previous instances of this script (avoid duplicates)
kill_previous() {
    local my_pid=$$
    local pids
    pids="$(pgrep -f "mados-wallpaper-glitch" 2>/dev/null)" || true
    for pid in $pids; do
        if [[ "$pid" != "$my_pid" ]]; then
            kill "$pid" 2>/dev/null || true
            log "killed previous instance PID $pid"
        fi
    done
}

# ── SQLite helpers ──────────────────────────────────────────────────────

# Initialise the database schema (idempotent)
init_db() {
    mkdir -p "$DB_DIR"
    sqlite3 "$DB_PATH" <<'SQL'
PRAGMA journal_mode=WAL;
CREATE TABLE IF NOT EXISTS wallpapers (
    id   INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT    UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS assignments (
    workspace    INTEGER PRIMARY KEY,
    wallpaper_id INTEGER NOT NULL REFERENCES wallpapers(id)
);
SQL
    log "database ready at $DB_PATH"
}

# Synchronise the WALLPAPER_DIR contents into the wallpapers table.
sync_wallpapers_to_db() {
    local count
    while IFS= read -r -d '' file; do
        local escaped
        escaped="${file//\'/\'\'}"  
        sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO wallpapers(path) VALUES('$escaped');"
    done < <(find "$WALLPAPER_DIR" -maxdepth 1 -type f \
        \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.webp' \) \
        -print0 | sort -z)

    # Remove rows whose files no longer exist on disk
    sqlite3 "$DB_PATH" "SELECT id, path FROM wallpapers;" | while IFS='|' read -r wid wpath; do
        if [[ ! -f "$wpath" ]]; then
            sqlite3 "$DB_PATH" "DELETE FROM wallpapers WHERE id=$wid;"
            sqlite3 "$DB_PATH" "DELETE FROM assignments WHERE wallpaper_id=$wid;"
            log "removed missing wallpaper: $wpath"
        fi
    done

    count="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM wallpapers;")"
    if [[ "$count" -eq 0 ]]; then
        log "ERROR: no wallpapers found in $WALLPAPER_DIR"
        return 1
    fi
    log "wallpaper catalog: $count entries"
    return 0
}

# Collect available wallpaper IDs into WALLPAPERS array
collect_wallpapers() {
    WALLPAPERS=()
    while IFS='|' read -r wid wpath; do
        WALLPAPERS+=("$wid|$wpath")
    done < <(sqlite3 "$DB_PATH" "SELECT id, path FROM wallpapers ORDER BY path;")
    if [[ ${#WALLPAPERS[@]} -eq 0 ]]; then
        log "ERROR: wallpapers table is empty"
        return 1
    fi
    log "found ${#WALLPAPERS[@]} wallpapers in database"
    return 0
}

# Fisher-Yates shuffle of WALLPAPERS array (in-place)
shuffle_wallpapers() {
    local i j tmp
    for (( i=${#WALLPAPERS[@]}-1; i>0; i-- )); do
        j=$(( RANDOM % (i+1) ))
        tmp="${WALLPAPERS[i]}"
        WALLPAPERS[i]="${WALLPAPERS[j]}"
        WALLPAPERS[j]="$tmp"
    done
}

# Write randomised wallpaper assignments into the database.
# Preserves existing user assignments.
assign_wallpapers() {
    local count=${#WALLPAPERS[@]}
    local existing
    existing="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments;")"

    if [[ "$existing" -gt 0 ]]; then
        local invalid
        invalid="$(sqlite3 "$DB_PATH" \
            "SELECT a.workspace FROM assignments a LEFT JOIN wallpapers w ON a.wallpaper_id=w.id WHERE w.id IS NULL;")"
        if [[ -n "$invalid" ]]; then
            for ws in $invalid; do
                sqlite3 "$DB_PATH" "DELETE FROM assignments WHERE workspace=$ws;"
                log "removed stale assignment for workspace $ws"
            done
            existing="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments;")"
        fi
    fi

    if [[ "$existing" -ge "$MAX_WORKSPACES" ]]; then
        log "all $MAX_WORKSPACES workspaces already assigned, keeping existing"
        return 0
    fi

    for (( ws=1; ws<=MAX_WORKSPACES; ws++ )); do
        local has
        has="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments WHERE workspace=$ws;")"
        if [[ "$has" -eq 0 ]]; then
            local idx=$(( (ws - 1) % count ))
            local entry="${WALLPAPERS[$idx]}"
            local wid="${entry%%|*}"
            local wpath="${entry#*|}"
            sqlite3 "$DB_PATH" "INSERT OR REPLACE INTO assignments(workspace, wallpaper_id) VALUES($ws, $wid);"
            log "workspace $ws -> $(basename "$wpath")"
        fi
    done
}

# Read wallpaper path for a given workspace from the database
get_wallpaper_for_ws() {
    local ws="$1"
    sqlite3 "$DB_PATH" \
        "SELECT w.path FROM assignments a JOIN wallpapers w ON a.wallpaper_id=w.id WHERE a.workspace=$ws LIMIT 1;"
}

get_random_transition() {
    local idx=$(( RANDOM % ${#TRANSITIONS[@]} ))
    echo "${TRANSITIONS[$idx]}"
}

# Set wallpaper via swww with optional glitch transition effect
set_wallpaper() {
    local wallpaper="$1"
    local use_transition="${2:-true}"
    if [[ -z "$wallpaper" || ! -f "$wallpaper" ]]; then
        log "WARNING: wallpaper not found: ${wallpaper:-empty}"
        return 1
    fi

    if [[ "$use_transition" == "true" ]]; then
        local transition
        transition="$(get_random_transition)"
        swww img "$wallpaper" \
            --transition-type "$transition" \
            --transition-duration 0.4 \
            --transition-fps 60 \
            --transition-step 90 \
            --transition-angle 45 2>/dev/null
    else
        swww img "$wallpaper" --transition-type none 2>/dev/null
    fi
}

### Main ###

# Bail out early if required tools are missing
for cmd in swww socat sqlite3; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log "required command not found: $cmd — exiting silently"
        exit 0
    fi
done

# Verify Hyprland is running
if [[ -z "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]]; then
    log "HYPRLAND_INSTANCE_SIGNATURE not set — not running under Hyprland"
    exit 0
fi

kill_previous

# Wait for swww-daemon to be ready (up to 15s)
for attempt in $(seq 1 30); do
    if swww query >/dev/null 2>&1; then
        log "swww-daemon ready (attempt $attempt)"
        break
    fi
    sleep 0.5
done

if ! swww query >/dev/null 2>&1; then
    log "ERROR: swww-daemon not ready after 15s"
    exit 1
fi

# Initialise / update wallpaper database
init_db
sync_wallpapers_to_db || exit 1

# Collect, shuffle, assign
declare -a WALLPAPERS=()
collect_wallpapers || exit 1
shuffle_wallpapers
assign_wallpapers

# Determine current workspace
current_ws="$(hyprctl activeworkspace -j 2>/dev/null | jq -r '.id // empty' 2>/dev/null)" || true
[[ -z "$current_ws" || "$current_ws" == "null" ]] && current_ws=1

# Set initial wallpaper without transition (fast startup)
wp="$(get_wallpaper_for_ws "$current_ws")"
set_wallpaper "$wp" "false"
log "initial wallpaper set for workspace $current_ws"

# Track last workspace to avoid redundant wallpaper changes
last_ws="$current_ws"

# Listen for workspace change events from Hyprland IPC socket.
# Use process substitution (< <(...)) instead of pipe to avoid subshell,
# so that last_ws variable updates are visible in the main shell.
log "starting workspace event subscription"
while IFS= read -r event; do
    case "$event" in
        workspace\>\>*)
            ws_num="${event#workspace>>}"
            # Only change if workspace actually changed
            if [[ -n "$ws_num" && "$ws_num" =~ ^[0-9]+$ && "$ws_num" != "$last_ws" ]]; then
                wp="$(get_wallpaper_for_ws "$ws_num")"
                if [[ -n "$wp" ]]; then
                    set_wallpaper "$wp" "true"
                    last_ws="$ws_num"
                    log "workspace $ws_num -> $(basename "$wp")"
                fi
            fi
            ;;
    esac
done < <(socat -u "UNIX-CONNECT:$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock" - 2>/dev/null)

log "workspace subscription ended, exiting"
