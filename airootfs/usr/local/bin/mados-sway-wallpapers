#!/usr/bin/env bash
# mados-sway-wallpapers - Random per-workspace wallpapers for Sway
# On startup, assigns a random wallpaper from /usr/share/backgrounds/
# to each workspace and switches wallpaper on workspace focus events.
#
# Wallpaper catalog and per-workspace assignments are stored in a SQLite
# database at ~/.local/share/mados/wallpapers.db so they persist across
# reboots and can be read/edited by a future wallpaper-settings GUI.
#
# Architecture: single persistent jq --unbuffered pipeline that filters
# workspace focus events and emits only workspace numbers.  Zero forks
# per event — comparable to the Hyprland socat approach.

WALLPAPER_DIR="${WALLPAPER_DIR:-/usr/share/backgrounds}"
MAX_WORKSPACES=5
LOG_TAG="mados-sway-wallpapers"
DB_DIR="${HOME}/.local/share/mados"
DB_PATH="${DB_DIR}/wallpapers.db"

log() {
    logger -p user.info -t "$LOG_TAG" "$*" 2>/dev/null || true
    echo "$LOG_TAG: $*" >&2
}

cleanup() {
    log "daemon exiting, database preserved at $DB_PATH"
}
trap cleanup EXIT

# Kill previous instances of this script (avoid duplicates)
kill_previous() {
    local my_pid=$$
    local pids
    pids="$(pgrep -f "mados-sway-wallpapers" 2>/dev/null)" || true
    for pid in $pids; do
        if [[ "$pid" != "$my_pid" ]]; then
            kill "$pid" 2>/dev/null || true
            log "killed previous instance PID $pid"
        fi
    done
}

# ── SQLite helpers ──────────────────────────────────────────────────────

# Initialise the database schema (idempotent)
init_db() {
    mkdir -p "$DB_DIR"
    sqlite3 "$DB_PATH" <<'SQL'
PRAGMA journal_mode=WAL;
CREATE TABLE IF NOT EXISTS wallpapers (
    id   INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT    UNIQUE NOT NULL
);
CREATE TABLE IF NOT EXISTS assignments (
    workspace    INTEGER PRIMARY KEY,
    wallpaper_id INTEGER NOT NULL REFERENCES wallpapers(id)
);
SQL
    log "database ready at $DB_PATH"
}

# Synchronise the WALLPAPER_DIR contents into the wallpapers table.
# New files are inserted; files that no longer exist are removed.
sync_wallpapers_to_db() {
    local count
    # Insert new entries (ignore duplicates)
    while IFS= read -r -d '' file; do
        # Use printf to safely escape single quotes for SQL
        local escaped
        escaped="${file//\'/\'\'}"  
        sqlite3 "$DB_PATH" "INSERT OR IGNORE INTO wallpapers(path) VALUES('$escaped');"
    done < <(find "$WALLPAPER_DIR" -maxdepth 1 -type f \
        \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' -o -iname '*.webp' \) \
        -print0 | sort -z)

    # Remove rows whose files no longer exist on disk
    sqlite3 "$DB_PATH" "SELECT id, path FROM wallpapers;" | while IFS='|' read -r wid wpath; do
        if [[ ! -f "$wpath" ]]; then
            sqlite3 "$DB_PATH" "DELETE FROM wallpapers WHERE id=$wid;"
            sqlite3 "$DB_PATH" "DELETE FROM assignments WHERE wallpaper_id=$wid;"
            log "removed missing wallpaper: $wpath"
        fi
    done

    count="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM wallpapers;")"
    if [[ "$count" -eq 0 ]]; then
        log "ERROR: no wallpapers found in $WALLPAPER_DIR"
        return 1
    fi
    log "wallpaper catalog: $count entries"
    return 0
}

# Collect available wallpaper IDs into WALLPAPERS array (for shuffle)
collect_wallpapers() {
    WALLPAPERS=()
    while IFS='|' read -r wid wpath; do
        WALLPAPERS+=("$wid|$wpath")
    done < <(sqlite3 "$DB_PATH" "SELECT id, path FROM wallpapers ORDER BY path;")
    if [[ ${#WALLPAPERS[@]} -eq 0 ]]; then
        log "ERROR: wallpapers table is empty"
        return 1
    fi
    log "found ${#WALLPAPERS[@]} wallpapers in database"
    return 0
}

# Fisher-Yates shuffle of WALLPAPERS array (in-place)
shuffle_wallpapers() {
    local i j tmp
    for (( i=${#WALLPAPERS[@]}-1; i>0; i-- )); do
        j=$(( RANDOM % (i+1) ))
        tmp="${WALLPAPERS[i]}"
        WALLPAPERS[i]="${WALLPAPERS[j]}"
        WALLPAPERS[j]="$tmp"
    done
}

# Write randomised wallpaper assignments into the database.
# Only assigns workspaces that have no existing assignment (preserves
# user selections made via a future GUI).
assign_wallpapers() {
    local count=${#WALLPAPERS[@]}
    local existing
    existing="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments;")"

    if [[ "$existing" -gt 0 ]]; then
        # Verify existing assignments still reference valid wallpapers
        local invalid
        invalid="$(sqlite3 "$DB_PATH" \
            "SELECT a.workspace FROM assignments a LEFT JOIN wallpapers w ON a.wallpaper_id=w.id WHERE w.id IS NULL;")"
        if [[ -n "$invalid" ]]; then
            for ws in $invalid; do
                sqlite3 "$DB_PATH" "DELETE FROM assignments WHERE workspace=$ws;"
                log "removed stale assignment for workspace $ws"
            done
            existing="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments;")"
        fi
    fi

    if [[ "$existing" -ge "$MAX_WORKSPACES" ]]; then
        log "all $MAX_WORKSPACES workspaces already assigned, keeping existing"
        return 0
    fi

    # Fill any unassigned workspaces
    for (( ws=1; ws<=MAX_WORKSPACES; ws++ )); do
        local has
        has="$(sqlite3 "$DB_PATH" "SELECT COUNT(*) FROM assignments WHERE workspace=$ws;")"
        if [[ "$has" -eq 0 ]]; then
            local idx=$(( (ws - 1) % count ))
            local entry="${WALLPAPERS[$idx]}"
            local wid="${entry%%|*}"
            local wpath="${entry#*|}"
            sqlite3 "$DB_PATH" "INSERT OR REPLACE INTO assignments(workspace, wallpaper_id) VALUES($ws, $wid);"
            log "workspace $ws -> $(basename "$wpath")"
        fi
    done
}

# Read wallpaper path for a given workspace from the database
get_wallpaper_for_ws() {
    local ws="$1"
    sqlite3 "$DB_PATH" \
        "SELECT w.path FROM assignments a JOIN wallpapers w ON a.wallpaper_id=w.id WHERE a.workspace=$ws LIMIT 1;"
}

# Set wallpaper via swww with smooth fade transition (no black flash)
set_wallpaper() {
    local wallpaper="$1"
    local use_transition="${2:-true}"
    if [[ -z "$wallpaper" || ! -f "$wallpaper" ]]; then
        log "WARNING: wallpaper not found: ${wallpaper:-empty}"
        return 1
    fi
    if [[ "$use_transition" == "true" ]]; then
        swww img "$wallpaper" \
            --transition-type fade \
            --transition-duration 0.5 \
            --transition-fps 60 2>/dev/null
    else
        swww img "$wallpaper" --transition-type none 2>/dev/null
    fi
}

# Wait for sway IPC to be fully ready
wait_for_sway() {
    local attempt
    for attempt in $(seq 1 30); do
        if swaymsg -t get_tree >/dev/null 2>&1; then
            log "sway IPC ready (attempt $attempt)"
            return 0
        fi
        sleep 0.5
    done
    log "ERROR: sway IPC not ready after 15s"
    return 1
}

### Main ###

# Ensure required tools exist
for cmd in swaymsg jq sqlite3 swww; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        log "ERROR: required command not found: $cmd"
        exit 1
    fi
done

kill_previous
wait_for_sway || exit 1

# Brief pause to let sway finish initializing outputs
sleep 0.5

# Start swww-daemon if not already running (provides smooth transitions)
if ! swww query >/dev/null 2>&1; then
    swww-daemon &
    disown
    # Wait for swww-daemon to become ready
    for _attempt in $(seq 1 30); do
        swww query >/dev/null 2>&1 && break
        sleep 0.5
    done
fi

# Initialise / update wallpaper database
init_db
sync_wallpapers_to_db || exit 1

# Collect, shuffle, assign
declare -a WALLPAPERS=()
collect_wallpapers || exit 1
shuffle_wallpapers
assign_wallpapers

# Determine current workspace
last_ws="$(swaymsg -t get_workspaces 2>/dev/null \
    | jq -r '.[] | select(.focused==true) | .num' 2>/dev/null)" || true
[[ -z "$last_ws" || "$last_ws" == "null" ]] && last_ws=1

# Set initial wallpaper without transition (fast startup)
wp="$(get_wallpaper_for_ws "$last_ws")"
if ! set_wallpaper "$wp" "false"; then
    sleep 0.5
    set_wallpaper "$wp" "false" || true
fi
log "initial wallpaper set for workspace $last_ws"

# ── Event subscription ──────────────────────────────────────────────────
# Uses a single persistent jq --unbuffered process in the pipeline to
# filter workspace focus events and emit only the workspace number.
# This means ZERO forks per event — jq stays alive for the lifetime of
# the subscription, just like socat in the Hyprland daemon.
#
# Reconnects automatically if the subscription ends. Backoff only applies
# when reconnections happen faster than 5 seconds apart (crash loop).
log "starting workspace event subscription"

reconnect_count=0
last_reconnect=0

while true; do
    now="$(date +%s)"
    # Reset counter if last successful run lasted more than 10s
    if (( now - last_reconnect > 10 )); then
        reconnect_count=0
    fi

    log "subscribing to workspace events (attempt $((reconnect_count + 1)))"
    last_reconnect="$now"

    # Single persistent pipeline: swaymsg → jq → while read
    # jq --unbuffered ensures immediate delivery (no stdio buffering)
    # jq runs ONCE as a long-lived filter, not forked per event
    while IFS= read -r ws_num; do
        # jq already filtered and extracted — ws_num is a clean number
        [[ -z "$ws_num" ]] && continue

        if [[ "$ws_num" =~ ^[0-9]+$ && "$ws_num" != "$last_ws" ]]; then
            wp="$(get_wallpaper_for_ws "$ws_num")"
            if [[ -n "$wp" ]]; then
                set_wallpaper "$wp"
                last_ws="$ws_num"
                log "workspace $ws_num -> $(basename "$wp")"
            fi
        fi
    done < <(swaymsg -t subscribe '["workspace"]' -m 2>&1 \
        | jq --unbuffered -r 'select(.change == "focus") | .current.num // empty' 2>/dev/null)

    reconnect_count=$((reconnect_count + 1))
    # Only backoff if reconnections are rapid (crash loop protection)
    if (( reconnect_count > 1 )); then
        backoff=$(( reconnect_count > 5 ? 10 : reconnect_count * 2 ))
        log "rapid reconnect detected, waiting ${backoff}s..."
        sleep "$backoff"
    else
        # Immediate reconnect on first failure
        sleep 0.5
    fi

    # Verify sway is still running before reconnecting
    if ! swaymsg -t get_version >/dev/null 2>&1; then
        log "sway IPC unavailable, exiting"
        break
    fi
done

log "wallpaper daemon exiting"
