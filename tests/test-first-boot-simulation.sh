#!/bin/bash
# =============================================================================
# madOS Config Script Simulation Test
# =============================================================================
# Validates the chroot configuration script generated by the installer.
# Since there is no Phase 2 / first-boot service, all configuration
# (including graphical environment verification) happens in the chroot
# config script during installation.
#
# This test validates:
#   1. The config script can be generated successfully
#   2. The script has valid bash syntax
#   3. The script is 100% offline (no internet downloads)
#   4. Graphical environment verification is present
#   5. No mados-first-boot references exist
#
# Note: This runs in a dry-run mode (syntax/logic check) without actually
# installing packages or modifying the system.
# =============================================================================
set -euo pipefail

# ── Paths (assumes repo is at /build in container or PWD otherwise) ─────────
REPO_DIR="${REPO_DIR:-$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)}"
LIB_DIR="${REPO_DIR}/airootfs/usr/local/lib"
TEST_DIR="$(mktemp -d)"

# ── Test parameters ──────────────────────────────────────────────────────────
TEST_USER="testuser"
TEST_LOCALE="en_US.UTF-8"

# ── Output helpers ───────────────────────────────────────────────────────────
RED='\033[0;31m'; GREEN='\033[0;32m'; YELLOW='\033[1;33m'; CYAN='\033[0;36m'; NC='\033[0m'
ERRORS=0; WARNINGS=0

step()    { local msg="$1"; echo -e "\n${CYAN}══════════════════════════════════════════════════${NC}"; echo -e "${GREEN}==> $msg${NC}"; return 0; }
info()    { local msg="$1"; echo -e "    ${YELLOW}$msg${NC}"; return 0; }
ok()      { local msg="$1"; echo -e "    ${GREEN}✓ $msg${NC}"; return 0; }
fail()    { local msg="$1"; echo -e "    ${RED}✗ $msg${NC}"; ERRORS=$((ERRORS + 1)); return 0; }
warn()    { local msg="$1"; echo -e "    ${YELLOW}⚠ $msg${NC}"; WARNINGS=$((WARNINGS + 1)); return 0; }

check_content() {
    local desc="$1" pattern="$2"
    if echo "$SCRIPT_CONTENT" | grep -qF "$pattern"; then
        ok "$desc"
    else
        fail "$desc (pattern not found: $pattern)"
    fi
}

check_not_content() {
    local desc="$1" pattern="$2"
    if echo "$SCRIPT_CONTENT" | grep -qF "$pattern"; then
        fail "$desc (found unwanted pattern: $pattern)"
    else
        ok "$desc"
    fi
}

# ── Cleanup on exit ──────────────────────────────────────────────────────────
cleanup() {
    step "Cleanup"
    rm -rf "$TEST_DIR"
    info "Test directory removed: $TEST_DIR"
    return 0
}
trap cleanup EXIT

# =============================================================================
# Phase 0: Environment setup (only needed in container environments)
# =============================================================================
# Check if we're in a container without python3 (e.g., fresh Arch Linux image)
if ! command -v python3 &>/dev/null; then
    step "Phase 0 – Setting up environment"
    
    # Configure DNS for network access
    echo 'nameserver 8.8.8.8' > /etc/resolv.conf
    echo 'nameserver 8.8.4.4' >> /etc/resolv.conf
    
    info "Initializing pacman keyring..."
    pacman-key --init
    pacman-key --populate
    
    info "Installing Python..."
    pacman -Syu --noconfirm python
    
    ok "Environment ready"
fi

# =============================================================================
# Phase 1: Generate the config script
# =============================================================================
step "Phase 1 – Generating config script"

if [[ ! -d "$LIB_DIR/mados_installer" ]]; then
    fail "Installer library not found at $LIB_DIR/mados_installer"
    exit 1
fi

# Python script to generate the config script
cat > "$TEST_DIR/generate_config.py" <<'EOFPYTHON'
import sys
import os

# Add lib dir to path
sys.path.insert(0, os.environ['LIB_DIR'])

# Mock GTK
import types
gi_mock = types.ModuleType("gi")
gi_mock.require_version = lambda *a, **kw: None
repo_mock = types.ModuleType("gi.repository")
class _StubMeta(type):
    def __getattr__(cls, name): return lambda *a, **kw: None
class _StubWidget(metaclass=_StubMeta):
    def __getattr__(self, name): return lambda *a, **kw: None
class _StubModule:
    def __getattr__(self, name): return _StubWidget
for name in ("Gtk", "GLib", "GdkPixbuf", "Gdk", "Pango"):
    setattr(repo_mock, name, _StubModule())
sys.modules["gi"] = gi_mock
sys.modules["gi.repository"] = repo_mock

# Import the installer
from mados_installer.pages.installation import _build_config_script

# Generate script with test data
data = {
    'username': os.environ.get('TEST_USER', 'testuser'),
    'locale': os.environ.get('TEST_LOCALE', 'en_US.UTF-8'),
    'timezone': 'America/Santiago',
    'disk': '/dev/sda',
    'password': 'testpass',
    'hostname': 'mados-test',
}

script = _build_config_script(data)
print(script)
EOFPYTHON

info "Generating config script via Python..."
export LIB_DIR TEST_USER TEST_LOCALE
if python3 "$TEST_DIR/generate_config.py" > "$TEST_DIR/config.sh"; then
    ok "Config script generated successfully"
else
    fail "Failed to generate config script"
    exit 1
fi

# =============================================================================
# Phase 2: Validate script syntax
# =============================================================================
step "Phase 2 – Validating bash syntax"

if bash -n "$TEST_DIR/config.sh"; then
    ok "Bash syntax is valid"
else
    fail "Bash syntax check failed"
fi

# Load content for further checks
SCRIPT_CONTENT=$(cat "$TEST_DIR/config.sh")
SCRIPT_LINES=$(wc -l < "$TEST_DIR/config.sh")
info "Generated script: $SCRIPT_LINES lines"

# =============================================================================
# Phase 3: Verify no Phase 2 / first-boot references
# =============================================================================
step "Phase 3 – Verifying no Phase 2 / first-boot service"

check_not_content "No mados-first-boot.sh" "mados-first-boot.sh"
check_not_content "No mados-first-boot.service" "mados-first-boot.service"
check_not_content "No Phase 2 references" "Phase 2"

# =============================================================================
# Phase 4: Verify graphical environment verification is present
# =============================================================================
step "Phase 4 – Verifying graphical environment verification"

check_content "Checks cage binary" "cage"
check_content "Checks regreet binary" "regreet"
check_content "Checks sway binary" "sway"
check_content "Checks cage-greeter script" "cage-greeter"
check_content "Checks greetd config" "greetd/config.toml"
check_content "Checks regreet config" "regreet.toml"
check_content "Checks hyprland-session" "hyprland-session"
check_content "Checks sway.desktop" "sway.desktop"
check_content "Checks hyprland.desktop" "hyprland.desktop"
check_content "Enables getty@tty2 fallback" "getty@tty2.service"
check_content "Verifies graphical env" "GRAPHICAL_OK"

# =============================================================================
# Phase 5: Verify the script is fully offline
# =============================================================================
step "Phase 5 – Verifying installer is 100% offline"

check_not_content "No pacman -Syu" "pacman -Syu"
check_not_content "No INTERNET_AVAILABLE" "INTERNET_AVAILABLE"
check_not_content "No git clone" "git clone"

# =============================================================================
# Phase 6: Verify progress markers use /8
# =============================================================================
step "Phase 6 – Verifying progress markers"

PROGRESS_COUNT=$(echo "$SCRIPT_CONTENT" | grep -c '\[PROGRESS' || true)
info "Found $PROGRESS_COUNT PROGRESS markers"

if echo "$SCRIPT_CONTENT" | grep -q 'PROGRESS.*9/'; then
    fail "Found PROGRESS 9/ marker (should be max 8)"
else
    ok "No PROGRESS 9/ marker found"
fi

if echo "$SCRIPT_CONTENT" | grep -q 'PROGRESS.*8/8'; then
    ok "Has PROGRESS 8/8 marker"
else
    fail "Missing PROGRESS 8/8 marker"
fi

# =============================================================================
# Summary
# =============================================================================
step "Test Summary"

echo ""
if [[ "$ERRORS" -gt 0 ]]; then
    echo -e "    ${RED}RESULT: $ERRORS ERRORS, $WARNINGS warnings${NC}"
    exit 1
else
    echo -e "    ${GREEN}RESULT: ALL TESTS PASSED ($WARNINGS warnings)${NC}"
    exit 0
fi
